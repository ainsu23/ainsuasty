{
  "hash": "0bf43612114fdb753834fa3707a674db",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Data Structures with R6Class\ndescription: \"Implement data structures with R6Class\" \ncategories: [\"R6Class\", \"Data Structures\"]\nmetadata-files: \n  - ../../_dataLabContent.yml\n---\n\n\n# Data Structures\n\nThis post is oriented to create classes that recreates data structures and\nexplanaition for each. Knowing this may help you improve as a programmer because\nis the basic of each language you would work R, python, c, javascript, others..\n\nData structures to work with:\n\n -    Arrays\n -    LinkedLists\n -    Hashtable\n -    Stacks\n -    Queues\n -    Trees\n -    Graphs\n\n\n::: {.panel-tabset}\n## Arrays\n\nR manages dinamics vectors, this means that one index can be added to an existed\nvector. For the purpose of this blog I would create a class R6Class to simmulate\nan Array. Within this array, you would be able to get an index, push a new item\nat the end, pop last item, delete an index.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyarray <- R6::R6Class(\n  classname = \"myarray\",\n  public = list(\n    initialize = function() {\n      self$array_length <- 0\n      self$array_data <- c()\n    },\n    array_length = NULL,\n    array_data = NULL,\n    get_value = function(index) {\n      return(self$array_data[index])\n    },\n    push = function(value) {\n      self$array_data[self$array_length + 1] = value\n      self$array_length <- length(self$array_data)\n    },\n    pop = function() {\n      lastItem <- self$array_data[self$array_length]\n      self$array_data <- self$array_data[-self$array_length]\n      self$array_length <- length(self$array_data)\n      return(lastItem)\n    },\n    delete = function(index) {\n      self$array_data <- self$array_data[-index]\n      self$array_length <- length(self$array_data)\n    }\n  )\n)\nmyarray = myarray$new()\nmyarray$push(2)\nmyarray$pop()\n```\n:::\n\n\n## LinkedLists\n\nLinkedLists are a set of nodes (that contains information related to where the data\nis stored in pc memory (pointers) and which node is next or previous).\nUntil my understanding, R does not have linkedList in its implementation, list\nare manage as vectors or arrays.\nThere exists 2 types or linked lists, one is single which it has just one\ndirection and double which has two directions.\n\nNevertheless, let's implement an double linkedList with R6Class:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_Linked_List <- R6::R6Class(\n  classname = \"linkedList\",\n  public = list(\n    # Initialize with the first value of the linkedList, .next would be NULL\n    initialize = function(value) {\n      self$list_pointer <- list(new.env())\n      self$list_pointer[[1]]$value <- value\n      self$index_head <- 1\n      self$index_tail <- 1\n      self$list_pointer[[1]]$index_next <- NULL\n      self$list_pointer[[1]]$index_prev <- NULL\n    },\n    list_pointer = NULL,\n    index_head = NULL,\n    index_tail = NULL,\n    # next is an used variable from R.\n    get_index = function(index) {\n      if (self$index_tail < index) stop(\"index not created yet!\")\n      return(self$list_pointer[[index]]$value)\n    },\n    insert = function(value) {\n      self$list_pointer <- self$list_pointer %>%\n        append(new.env())\n      self$index_tail <- self$index_tail + 1\n      self$list_pointer[[self$index_tail]]$index_prev <-\n        self$list_pointer[[self$index_tail - 1]]\n      self$list_pointer[[self$index_tail - 1]]$index_next <-\n        self$list_pointer[[self$index_tail]]\n      self$list_pointer[[self$index_tail]]$value <- value\n      self$list_pointer[[self$index_tail]]$index_next <- NULL\n      return(self$list_pointer)\n    }\n  )\n)\n```\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}