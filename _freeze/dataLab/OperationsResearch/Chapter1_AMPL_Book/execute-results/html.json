{
  "hash": "01527e802a9f3c1e7a59b3fe53e93406",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Chapter 1 - AMPL Book\ndescription: \"Solution to exercises in Chapter 1\" \ncategories: [\"Linear programming\", \"R\", \"AMPL\", \"python\"]\nimage: ../../image/linear_programming.png\nmetadata-files: \n  - ../../_dataLabContent.yml\nexecute: \n  cache: true\n---\n\n\nHi Folks!\n\nSince my bachelor degree I always wanted to resolved the exercises of AMPL's book,\nIn my course I studied with AMPL and in my master I also used AMPL, I find it \nvery easy to get into operation research world!.\n\nHave fun with me during solving some exercises from the book, I have used the API's\nthat AMPL is giving us, so some problems are solved using python and others with R.\n\nI tried to keep the original model and data in different files and folders. When\na model requires to be changed, I do it using the ampl API.\n\n\n## 0. Installing rAMPL and amplpy\n\n### rAMPL\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::install(\"https://ampl.com/dl/API/rAMPL.tar.gz\", repos=NULL, INSTALL_opts=c(\"--no-multiarch\", \"--no-staged-install\"))\n```\n:::\n\n  \n  \n### amplpy\nIn order to use the free license of ampl community, it is required to input the \nlicense number after --uuid.\n\n```{{r}}\nreticulate::py_install(\"jupyter\")\nreticulate::py_install(\"amplpy\")\nreticulate::py_install(\"pandas\")\nsystem2(reticulate::py_exe(), c(\"-m\", \"amplpy.modules\", \"install\", \"highs\"))\nsystem2(reticulate::py_exe(), c(\"-m\", \"amplpy.modules\", \"run\", \"amplkey\", \"activate\", \"--UUID\"))\nsystem2(reticulate::py_exe(), c(\"-m\", \"amplpy.modules\", \"run\", \"ampl\", \"-vvq\"))\n\n```\n\n# 1. Optimize advertising campaigns (rAMPL)\n\nThe objective of this exercise is to chose the number of units to purchase in \neach channel to advertise. Let's figure out together how to do it. \n\n\n::: {.cell}\n\n:::\n\n\nSetting a new environment for make the conection through the API with AMPL\n\n::: {.cell}\n\n:::\n\n\n## a. Subjetct to budget\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# creating vectors with information\nunits <- c(\"tv_mins\", \"magazine_pages\")\ncost <- c(20000, 10000)\nreach <- c(1.8, 1)\nmin_units <- c(10, 1)\n\n# Loading class and setting solver\nampl <- new(AMPL, env)\nampl$setOption(\"solver\",\"HiGHS\") \n\nampl$eval(\"param p_budget := 1000000;\")\n# Loading model\nampl$read(\"models/1.1 Advertising_campaigns.mod\")\n\n# Setting Data\nampl$setData(\n  data.frame(\n    units = units, \n    cost = cost, \n    reach = reach, \n    min_units = min_units\n  ), 1, \"units\"\n) \n# Formulation\nampl$eval(\"var buy{u in units} >= min_units[u];\")\nampl$eval(\"maximize Audience: sum {u in units} buy[u] * reach[u];\")\nampl$eval(\"subject to budget: sum {u in units} buy[u] * cost[u] <= p_budget;\")\n\nampl$solve()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHiGHS 1.7.0: \b\b\b\b\b\b\b\b\b\b\b\b\bHiGHS 1.7.0: optimal solution; objective 98\n0 simplex iterations\n0 barrier iterations\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(ampl$getVariable(\"buy\")$getValues())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          index0 buy.val\n1 magazine_pages      80\n2        tv_mins      10\n```\n\n\n:::\n\n```{.r .cell-code}\nampl$close()\n```\n:::\n\n\n## b. Adding constraint time needed to build campaign\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunits <- c(\"tv_mins\", \"magazine_pages\")\ncost <- c(20000, 10000)\nreach <- c(1.8, 1)\nmin_units <- c(10, 1)\nperson_weeks <- c(1, 3)\n\n# loading class and setting solver\nampl <- new(AMPL, env)\nampl$setOption(\"solver\",\"highs\") \n\n# Adding parameters\nampl$eval(\"param p_budget := 1000000;\")\nampl$eval(\"param max_person_weeks := 100;\")\n# loading model\nampl$read(\"models/1.1 advertising_campaigns.mod\") # read model located in folder models\n\n# setting data\nampl$setData(\n  data.frame(\n    units = units, \n    cost = cost, \n    reach = reach, \n    min_units = min_units,\n    person_weeks = person_weeks\n  ), 1, \"units\"\n) \n# formulation\nampl$eval(\"var buy{u in units} >= min_units[u];\")\nampl$eval(\"maximize audience: sum {u in units} buy[u] * reach[u];\")\nampl$eval(\"subject to budget: sum {u in units} buy[u] * cost[u] <= p_budget;\")\nampl$eval(\"subject to capacity: sum {u in units} buy[u] * person_weeks[u] <= max_person_weeks;\")\n\nampl$solve()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHiGHS 1.7.0: \b\b\b\b\b\b\b\b\b\b\b\b\bHiGHS 1.7.0: optimal solution; objective 92\n2 simplex iterations\n0 barrier iterations\n```\n\n\n:::\n\n```{.r .cell-code}\nampl$getVariable(\"buy\")$getValues()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          index0 buy.val\n1 magazine_pages      20\n2        tv_mins      40\n```\n\n\n:::\n\n```{.r .cell-code}\nampl$close()\n```\n:::\n\n\n## c. Adding channel radio\nModel keeps the same as previous, but data changes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Adding channel to data\nunits <- c(\"tv_mins\", \"magazine_pages\", \"radio_min\")\ncost <- c(20000, 10000, 2000)\nreach <- c(1.8, 1, 0.25)\nmin_units <- c(10, 1, 1)\nperson_weeks <- c(1, 3, 1/7)\n\n# loading class and setting solver\nampl <- new(AMPL, env)\nampl$setOption(\"solver\",\"HiGHS\") \n\nampl$eval(\"param p_budget := 1000000;\")\nampl$eval(\"param max_person_weeks := 100;\")\n# loading model\nampl$read(\"models/1.1 advertising_campaigns.mod\") # read model located in folder models\n\n# setting data\nampl$setData(\n  data.frame(\n    units = units, \n    cost = cost, \n    reach = reach, \n    min_units = min_units,\n    person_weeks = person_weeks\n  ), 1, \"units\"\n) \n# formulation\nampl$eval(\"var buy{u in units} >= min_units[u];\")\nampl$eval(\"maximize audience: sum {u in units} buy[u] * reach[u];\")\nampl$eval(\"subject to budget: sum {u in units} buy[u] * cost[u] <= p_budget;\")\nampl$eval(\"subject to capacity: sum {u in units} buy[u] * person_weeks[u] <= max_person_weeks;\")\n\nampl$solve()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHiGHS 1.7.0: \b\b\b\b\b\b\b\b\b\b\b\b\bHiGHS 1.7.0: optimal solution; objective 117.75\n1 simplex iterations\n0 barrier iterations\n```\n\n\n:::\n\n```{.r .cell-code}\nampl$getVariable(\"buy\")$getValues()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          index0 buy.val\n1 magazine_pages       1\n2      radio_min     395\n3        tv_mins      10\n```\n\n\n:::\n\n```{.r .cell-code}\nampl$close()\n```\n:::\n\n\n\n# 2. Steel model with changes (amplpy) \n\nBefore solving execises, let's review steel4 model explained in the chapter. \n\n## Steel4 model\n\n::: {.panel-tabset}\n\n## amplpy\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom amplpy import AMPL, modules\nmodules.load() # load all modules\nampl = AMPL() # instantiate AMPL object}\nampl.option[\"solver\"] = \"highs\"\nampl.read(\"models/steel_original.mod\") # read model located in folder models\nampl.read_data(\"data/steel_original.dat\") # read dat located in folder models\nampl.solve()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHiGHS 1.7.0: \b\b\b\b\b\b\b\b\b\b\b\b\bHiGHS 1.7.0: optimal solution; objective 190071.4286\n2 simplex iterations\n0 barrier iterations\n```\n\n\n:::\n\n```{.python .cell-code}\ndf = ampl.getVariable(\"Make\").getValues()\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   index0    |   Make.val  \n  'bands'    | 3357.142857142858\n  'coils'    |     500     \n  'plate'    | 3142.857142857143\n```\n\n\n:::\n\n```{.python .cell-code}\nampl.reset()\nampl.close()\n```\n:::\n\n\n## steel_original.mod\n\nModel developed in `AMPL`\n\n```{{AMPL}}\n\nset PROD; # products\nset STAGE; # stages\n\nparam rate {PROD,STAGE} > 0; # tons per hour in each stage\nparam avail {STAGE} >= 0; # hours available/week in each stage\nparam profit {PROD}; # profit per ton\nparam commit {PROD} >= 0; # lower limit on tons sold in week\nparam market {PROD} >= 0; # upper limit on tons sold in week\nvar Make {p in PROD} >= commit[p], <= market[p]; # tons produced\n\nmaximize Total_Profit: sum {p in PROD} profit[p] * Make[p];\n# Objective: total profits from all products\n\nsubject to Time {s in STAGE}:\nsum {p in PROD} (1/rate[p,s]) * Make[p] <= avail[s];\n\n# In each stage: total of hours used by all\n# products may not exceed hours available\n```\n\n## steel_original.dat\n\nData input in `AMPL`\n```{{AMPL}}\n\nset PROD := bands coils plate;\nset STAGE := reheat roll;\n\nparam rate: reheat roll :=\n  bands 200 200\n  coils 200 140\n  plate 200 160 ;\n\nparam: profit commit market :=\n  bands 25 1000 6000\n  coils 30 500 4000\n  plate 29 750 3500 ;\n\nparam avail := reheat 35 roll 40 ;\n```\n\n:::\n\n## a. Change constrain to equal\nAs the objective functions is a maximization, the problem would try to achive\nthe equality as their is not another constraint. Therefore, changing the equality\nfrom `<=` to `=` does not change the result.\n\n```{{AMPL}}\nsubject to Time {s in STAGE}:\nsum {p in PROD} (1/rate[p,s]) * Make[p] = avail[s];\n```\n\n## b. Max total weigth contraint\nAdding a new constraint to put a upper bound to the variable Make.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Loading class and setting solver\nampl = AMPL() # instantiate AMPL object\nampl.option[\"solver\"] = \"highs\"\n\n# Load model and data\nampl.read(\"models/steel_original.mod\") # read model located in folder models\nampl.read_data(\"data/steel_original.dat\") # read dat located in folder models\n\n## Adding new constraint to limit tons manufactured.\nampl.eval(\"param max_weight := 6500;\")\nampl.eval(\"subject to MaxWeight: sum {p in PROD} Make[p] <= max_weight;\")\n\n# Solving problem\nampl.solve()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHiGHS 1.7.0: \b\b\b\b\b\b\b\b\b\b\b\b\bHiGHS 1.7.0: optimal solution; objective 183791.6667\n3 simplex iterations\n0 barrier iterations\n```\n\n\n:::\n\n```{.python .cell-code}\ndf = ampl.getVariable(\"Make\").getValues()\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   index0    |   Make.val  \n  'bands'    | 1541.666666666667\n  'coils'    | 1458.333333333333\n  'plate'    |     3500    \n```\n\n\n:::\n\n```{.python .cell-code}\nampl.close()\n```\n:::\n\n\n## c. Produce as many tons as possible\n\nThe idea behind increase number of tons is to keep the objective functions, nevertheless,\nwithout the params profit.\n\n```{{AMPL}}\n\nmaximize tons: sum {p in PROD} Make[p];\n# Objective: total profits from all products\n\n```\n\n## d. Lower bounds as constraints.\nIn this exercise we are asked to change the minimum of the tons make for each \nproduct, therefore, we required to redeclare the var to delete the lower bound. \n\n\n::: {.cell}\n\n```{.python .cell-code}\n# import  libraries\nimport pandas as pd\n\n# Loading class and setting solver\nampl = AMPL() # instantiate AMPL object\nampl.option[\"solver\"] = \"highs\"\n\n# Load model and data\nampl.read(\"models/steel_original.mod\") # read model located in folder models\nampl.read_data(\"data/steel_original.dat\") # read dat located in folder models\n\n## Changing in formulation\nampl.eval(\"param shares {PROD};\")\n\n# Creation of a list to input ampl\nshares_list = {\"bands\": 0.4, \"coils\": 0.1, \"plate\": 0.4}\n\n# Inputing the list into the param shares created\nampl.param[\"shares\"] = {PROD: shares for PROD, (shares) in shares_list.items()}\n\n# Redeclare var Make to delete lower bound\nampl.eval(\"redeclare var Make {p in PROD} <= market[p];\")\n\n# Create a new constraint with the lower bound by product\nampl.eval(\"subject to min_shares {j in PROD}: Make[j] >= shares[j] * sum {k in PROD} Make[k];\")\n\n# Solving problem\nampl.solve()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHiGHS 1.7.0: \b\b\b\b\b\b\b\b\b\b\b\b\bHiGHS 1.7.0: optimal solution; objective 189700\n5 simplex iterations\n0 barrier iterations\n```\n\n\n:::\n\n```{.python .cell-code}\ndf = ampl.getVariable(\"Make\").getValues()\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   index0    |   Make.val  \n  'bands'    |     3500    \n  'coils'    |     700     \n  'plate'    |     2800    \n```\n\n\n:::\n\n```{.python .cell-code}\nampl.close()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}